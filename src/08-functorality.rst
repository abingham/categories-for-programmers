.. raw:: html

   <div id="rap">

.. raw:: html

   <div id="header">

-  `Home <https://bartoszmilewski.com>`__
-  `About <https://bartoszmilewski.com/about/>`__

.. raw:: html

   <div id="headimg">

.. rubric:: `  Bartosz Milewski's Programming
   Cafe <https://bartoszmilewski.com>`__
   :name: bartosz-milewskis-programming-cafe

.. raw:: html

   <div id="desc">

Concurrency, C++, Haskell, Category Theory

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="main">

.. raw:: html

   <div id="content">

.. raw:: html

   <div
   class="post-4008 post type-post status-publish format-standard hentry category-c category-category-theory category-functional-programming category-haskell category-programming">

February 3, 2015

.. raw:: html

   <div class="post-info">

.. rubric:: Functoriality
   :name: functoriality
   :class: post-title

Posted by Bartosz Milewski under
`C++ <https://bartoszmilewski.com/category/c/>`__, `Category
Theory <https://bartoszmilewski.com/category/category-theory/>`__,
`Functional
Programming <https://bartoszmilewski.com/category/functional-programming/>`__,
`Haskell <https://bartoszmilewski.com/category/haskell/>`__,
`Programming <https://bartoszmilewski.com/category/programming/>`__
`[18]
Comments <https://bartoszmilewski.com/2015/02/03/functoriality/#comments>`__ 

.. raw:: html

   </div>

.. raw:: html

   <div class="post-content">

.. raw:: html

   <div id="pd_rating_holder_2203687_post_4008" class="pd-rating">

.. raw:: html

   </div>

    This is part 8 of Categories for Programmers. Previously: Functors.
    See the `Table of
    Contents <https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/>`__.

Now that you know what a functor is, and have seen a few examples, let’s
see how we can build larger functors from smaller ones. In particular
it’s interesting to see which type constructors (which correspond to
mappings between objects in a category) can be extended to functors
(which include mappings between morphisms).

.. rubric:: Bifunctors
   :name: bifunctors

Since functors are morphisms in *Cat* (the category of categories), a
lot of intuitions about morphisms — and functions in particular — apply
to functors as well. For instance, just like you can have a function of
two arguments, you can have a functor of two arguments, or a
*bifunctor*. On objects, a bifunctor maps every pair of objects, one
from category C, and one from category D, to an object in category E.
Notice that this is just saying that it’s a mapping from a *cartesian
product* of categories C×D to E.

|Bifunctor|

That’s pretty straightforward. But functoriality means that a bifunctor
has to map morphisms as well. This time, though, it must map a pair of
morphisms, one from C and one from D, to a morphism in E.

Again, a pair of morphisms is just a single morphism in the product
category C×D. We define a morphism in a cartesian product of categories
as a pair of morphisms which goes from one pair of objects to another
pair of objects. These pairs of morphisms can be composed in the obvious
way:

::

    (f, g) ∘ (f', g') = (f ∘ f', g ∘ g')

The composition is associative and it has an identity — a pair of
identity morphisms *(id, id)*. So a cartesian product of categories is
indeed a category.

But an easier way to think about bifunctors is that they are functors in
both arguments. So instead of translating functorial laws —
associativity and identity preservation — from functors to bifunctors,
it’s enough to check them separately for each argument. If you have a
mapping from a pair of categories to a third category, and you prove
that it is functorial in each argument separately (i.e., keeping the
other argument constant), then the mapping is automatically a bifunctor.
By *functorial* I mean that it acts on morphisms like an honest functor.

Let’s define a bifunctor in Haskell. In this case all three categories
are the same: the category of Haskell types. A bifunctor is a type
constructor that takes two type arguments. Here’s the definition of the
``Bifunctor`` typeclass taken directly from the library
``Control.Bifunctor``:

::

    class Bifunctor f where
        bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
        bimap g h = first g . second h
        first :: (a -> c) -> f a b -> f c b
        first g = bimap g id
        second :: (b -> d) -> f a b -> f a d
        second = bimap id

The type variable ``f`` represents the bifunctor. You can see that in
all type signatures it’s always applied to two type arguments. The first
type signature defines ``bimap``: a mapping of two functions at once.
The result is a lifted function, ``(f a b -> f c d)``, operating on
types generated by the bifunctor’s type constructor. There is a default
implementation of ``bimap`` in terms of ``first`` and ``second``, which
shows that it’s enough to have functoriality in each argument separately
to be able to define a bifunctor.

.. raw:: html

   <div id="attachment_4070" class="wp-caption aligncenter"
   data-shortcode="caption" style="width: 310px">

|Bimap|
bimap

.. raw:: html

   </div>

The two other type signatures, ``first`` and ``second``, are the two
``fmap``\ s witnessing the functoriality of ``f`` in the first and the
second argument, respectively.

+--------------------------------------+--------------------------------------+
| .. raw:: html                        | .. raw:: html                        |
|                                      |                                      |
|    <div id="attachment_4071"         |    <div id="attachment_4072"         |
|    class="wp-caption aligncenter"    |    class="wp-caption aligncenter"    |
|    data-shortcode="caption"          |    data-shortcode="caption"          |
|    style="width: 160px">             |    style="width: 160px">             |
|                                      |                                      |
| |First|                              | |Second|                             |
| first                                | second                               |
|                                      |                                      |
| .. raw:: html                        | .. raw:: html                        |
|                                      |                                      |
|    </div>                            |    </div>                            |
+--------------------------------------+--------------------------------------+

The typeclass definition provides default implementations for both of
them in terms of ``bimap``.

When declaring an instance of ``Bifunctor``, you have a choice of either
implementing ``bimap`` and accepting the defaults for ``first`` and
``second``, or implementing both ``first`` and ``second`` and accepting
the default for ``bimap`` (of course, you may implement all three of
them, but then it’s up to you to make sure they are related to each
other in this manner).

.. rubric:: Product and Coproduct Bifunctors
   :name: product-and-coproduct-bifunctors

An important example of a bifunctor is the categorical product — a
product of two objects that is defined by a `universal
construction <https://bartoszmilewski.com/2015/01/07/products-and-coproducts/>`__.
If the product exists for any pair of objects, the mapping from those
objects to the product is bifunctorial. This is true in general, and in
Haskell in particular. Here’s the ``Bifunctor`` instance for a pair
constructor — the simplest product type:

::

    instance Bifunctor (,) where
        bimap f g (x, y) = (f x, g y)

There isn’t much choice: ``bimap`` simply applies the first function to
the first component, and the second function to the second component of
a pair. The code pretty much writes itself, given the types:

::

    bimap :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)

The action of the bifunctor here is to make pairs of types, for
instance:

::

    (,) a b = (a, b)

By duality, a coproduct, if it’s defined for every pair of objects in a
category, is also a bifunctor. In Haskell, this is exemplified by the
``Either`` type constructor being an instance of ``Bifunctor``:

::

    instance Bifunctor Either where
        bimap f _ (Left x)  = Left (f x)
        bimap _ g (Right y) = Right (g y)

This code also writes itself.

Now, remember when we talked about monoidal categories? A monoidal
category defines a binary operator acting on objects, together with a
unit object. I mentioned that ``Set`` is a monoidal category with
respect to cartesian product, with the singleton set as a unit. And it’s
also a monoidal category with respect to disjoint union, with the empty
set as a unit. What I haven’t mentioned is that one of the requirements
for a monoidal category is that the binary operator be a bifunctor. This
is a very important requirement — we want the monoidal product to be
compatible with the structure of the category, which is defined by
morphisms. We are now one step closer to the full definition of a
monoidal category (we still need to learn about naturality, before we
can get there).

.. rubric:: Functorial Algebraic Data Types
   :name: functorial-algebraic-data-types

We’ve seen several examples of parameterized data types that turned out
to be functors — we were able to define ``fmap`` for them. Complex data
types are constructed from simpler data types. In particular, algebraic
data types (ADTs) are created using sums and products. We have just seen
that sums and products are functorial. We also know that functors
compose. So if we can show that the basic building blocks of ADTs are
functorial, we’ll know that parameterized ADTs are functorial too.

So what are the building blocks of parameterized algebraic data types?
First, there are the items that have no dependency on the type parameter
of the functor, like ``Nothing`` in ``Maybe``, or ``Nil`` in ``List``.
They are equivalent to the ``Const`` functor. Remember, the ``Const``
functor ignores its type parameter (really, the *second* type parameter,
which is the one of interest to us, the first one being kept constant).

Then there are the elements that simply encapsulate the type parameter
itself, like ``Just`` in ``Maybe``. They are equivalent to the identity
functor. I mentioned the identity functor previously, as the identity
morphism in *Cat*, but didn’t give its definition in Haskell. Here it
is:

::

    data Identity a = Identity a

::

    instance Functor Identity where
        fmap f (Identity x) = Identity (f x)

You can think of ``Identity`` as the simplest possible container that
always stores just one (immutable) value of type ``a``.

Everything else in algebraic data structures is constructed from these
two primitives using products and sums.

With this new knowledge, let’s have a fresh look at the ``Maybe`` type
constructor:

::

    data Maybe a = Nothing | Just a

It’s a sum of two types, and we now know that the sum is functorial. The
first part, ``Nothing`` can be represented as a ``Const ()`` acting on
``a`` (the first type parameter of ``Const`` is set to unit — later
we’ll see more interesting uses of ``Const``). The second part is just a
different name for the identity functor. We could have defined
``Maybe``, up to isomorphism, as:

::

    type Maybe a = Either (Const () a) (Identity a)

So ``Maybe`` is the composition of the bifunctor ``Either`` with two
functors, ``Const ()`` and ``Identity``. (``Const`` is really a
bifunctor, but here we always use it partially applied.)

We’ve already seen that a composition of functors is a functor — we can
easily convince ourselves that the same is true of bifunctors. All we
need is to figure out how a composition of a bifunctor with two functors
works on morphisms. Given two morphisms, we simply lift one with one
functor and the other with the other functor. We then lift the resulting
pair of lifted morphisms with the bifunctor.

We can express this composition in Haskell. Let’s define a data type
that is parameterized by a bifunctor ``bf`` (it’s a type variable that
is a type constructor that takes two types as arguments), two functors
``fu`` and ``gu`` (type constructors that take one type variable each),
and two regular types ``a`` and ``b``. We apply ``fu`` to ``a`` and
``gu`` to ``b``, and then apply ``bf`` to the resulting two types:

::

    newtype BiComp bf fu gu a b = BiComp (bf (fu a) (gu b))

That’s the composition on objects, or types. Notice how in Haskell we
apply type constructors to types, just like we apply functions to
arguments. The syntax is the same.

If you’re getting a little lost, try applying ``BiComp`` to ``Either``,
``Const ()``, ``Identity``, ``a``, and ``b``, in this order. You will
recover our bare-bone version of ``Maybe b`` (``a`` is ignored).

The new data type ``BiComp`` is a bifunctor in ``a`` and ``b``, but only
if ``bf`` is itself a ``Bifunctor`` and ``fu`` and ``gu`` are
``Functor``\ s. The compiler must know that there will be a definition
of ``bimap`` available for ``bf``, and definitions of ``fmap`` for
``fu`` and ``gu``. In Haskell, this is expressed as a precondition in
the instance declaration: a set of class constraints followed by a
double arrow:

::

    instance (Bifunctor bf, Functor fu, Functor gu) =>
      Bifunctor (BiComp bf fu gu) where
        bimap f1 f2 (BiComp x) = BiComp ((bimap (fmap f1) (fmap f2)) x)

The implementation of ``bimap`` for ``BiComp`` is given in terms of
``bimap`` for ``bf`` and the two ``fmap``\ s for ``fu`` and ``gu``. The
compiler automatically infers all the types and picks the correct
overloaded functions whenever ``BiComp`` is used.

The ``x`` in the definition of ``bimap`` has the type:

::

    bf (fu a) (gu b)

which is quite a mouthful. The outer ``bimap`` breaks through the outer
``bf`` layer, and the two ``fmap``\ s dig under ``fu`` and ``gu``,
respectively. If the types of ``f1`` and ``f2`` are:

::

    f1 :: a -> a'
    f2 :: b -> b'

then the final result is of the type ``bf (fu a') (gu b')``:

::

    bimap (fu a -> fu a') -> (gu b -> gu b') 
      -> bf (fu a) (gu b) -> bf (fu a') (gu b')

If you like jigsaw puzzles, these kinds of type manipulations can
provide hours of entertainment.

So it turns out that we didn’t have to prove that ``Maybe`` was a
functor — this fact followed from the way it was constructed as a sum of
two functorial primitives.

A perceptive reader might ask the question: If the derivation of the
``Functor`` instance for algebraic data types is so mechanical, can’t it
be automated and performed by the compiler? Indeed, it can, and it is.
You need to enable a particular Haskell extension by including this line
at the top of your source file:

::

    {-# LANGUAGE DeriveFunctor #-}

and then add ``deriving Functor`` to your data structure:

::

    data Maybe a = Nothing | Just a
      deriving Functor

and the corresponding ``fmap`` will be implemented for you.

The regularity of algebraic data structures makes it possible to derive
instances not only of ``Functor`` but of several other type classes,
including the ``Eq`` type class I mentioned before. There is also the
option of teaching the compiler to derive instances of your own
typeclasses, but that’s a bit more advanced. The idea though is the
same: You provide the behavior for the basic building blocks and sums
and products, and let the compiler figure out the rest.

.. rubric:: Functors in C++
   :name: functors-in-c

If you are a C++ programmer, you obviously are on your own as far as
implementing functors goes. However, you should be able to recognize
some types of algebraic data structures in C++. If such a data structure
is made into a generic template, you should be able to quickly implement
``fmap`` for it.

Let’s have a look at a tree data structure, which we would define in
Haskell as a recursive sum type:

::

    data Tree a = Leaf a | Node (Tree a) (Tree a)
        deriving Functor

As I mentioned before, one way of implementing sum types in C++ is
through class hierarchies. It would be natural, in an object-oriented
language, to implement ``fmap`` as a virtual function of the base class
``Functor`` and then override it in all subclasses. Unfortunately this
is impossible because ``fmap`` is a template, parameterized not only by
the type of the object it’s acting upon (the ``this`` pointer) but also
by the return type of the function that’s been applied to it. Virtual
functions cannot be templatized in C++. We’ll implement ``fmap`` as a
generic free function, and we’ll replace pattern matching with
``dynamic_cast``.

The base class must define at least one virtual function in order to
support dynamic casting, so we’ll make the destructor virtual (which is
a good idea in any case):

::

    template<class T>
    struct Tree {
        virtual ~Tree() {};
    };

The ``Leaf`` is just an ``Identity`` functor in disguise:

::

    template<class T>
    struct Leaf : public Tree<T> {
        T _label;
        Leaf(T l) : _label(l) {}
    };

The ``Node`` is a product type:

::

    template<class T>
    struct Node : public Tree<T> {
        Tree<T> * _left;
        Tree<T> * _right;
        Node(Tree<T> * l, Tree<T> * r) : _left(l), _right(r) {}
    };

When implementing ``fmap`` we take advantage of dynamic dispatching on
the type of the ``Tree``. The ``Leaf`` case applies the ``Identity``
version of ``fmap``, and the ``Node`` case is treated like a bifunctor
composed with two copies of the ``Tree`` functor. As a C++ programmer,
you’re probably not used to analyzing code in these terms, but it’s a
good exercise in categorical thinking.

::

    template<class A, class B>
    Tree<B> * fmap(std::function<B(A)> f, Tree<A> * t)
    {
        Leaf<A> * pl = dynamic_cast <Leaf<A>*>(t);
        if (pl)
            return new Leaf<B>(f (pl->_label));
        Node<A> * pn = dynamic_cast<Node<A>*>(t);
        if (pn)
            return new Node<B>( fmap<A>(f, pn->_left)
                              , fmap<A>(f, pn->_right));
        return nullptr;
    }

For simplicity, I decided to ignore memory and resource management
issues, but in production code you would probably use smart pointers
(unique or shared, depending on your policy).

Compare it with the Haskell implementation of ``fmap``:

::

    instance Functor Tree where
        fmap f (Leaf a) = Leaf (f a)
        fmap f (Node t t') = Node (fmap f t) (fmap f t')

This implementation can also be automatically derived by the compiler.

.. rubric:: The Writer Functor
   :name: the-writer-functor

I promised that I would come back to the `Kleisli
category <https://bartoszmilewski.com/2014/12/23/kleisli-categories/>`__
I described earlier. Morphisms in that category were represented as
“embellished” functions returning the ``Writer`` data structure.

::

    type Writer a = (a, String)

I said that the embellishment was somehow related to endofunctors. And,
indeed, the ``Writer`` type constructor is functorial in ``a``. We don’t
even have to implement ``fmap`` for it, because it’s just a simple
product type.

But what’s the relation between a Kleisli category and a functor — in
general? A Kleisli category, being a category, defines composition and
identity. Let’ me remind you that the composition is given by the fish
operator:

::

    (>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c)
    m1 >=> m2 = \x -> 
        let (y, s1) = m1 x
            (z, s2) = m2 y
        in (z, s1 ++ s2)

and the identity morphism by a function called ``return``:

::

    return :: a -> Writer a
    return x = (x, "")

It turns out that, if you look at the types of these two functions long
enough (and I mean, *long* enough), you can find a way to combine them
to produce a function with the right type signature to serve as
``fmap``. Like this:

::

    fmap f = id >=> (\x -> return (f x))

Here, the fish operator combines two functions: one of them is the
familiar ``id``, and the other is a lambda that applies ``return`` to
the result of acting with ``f`` on the lambda’s argument. The hardest
part to wrap your brain around is probably the use of ``id``. Isn’t the
argument to the fish operator supposed to be a function that takes a
“normal” type and returns an embellished type? Well, not really. Nobody
says that ``a`` in ``a -> Writer b`` must be a “normal” type. It’s a
type variable, so it can be anything, in particular it can be an
embellished type, like ``Writer b``.

So ``id`` will take ``Writer a`` and turn it into ``Writer a``. The fish
operator will fish out the value of ``a`` and pass it as ``x`` to the
lambda. There, ``f`` will turn it into a ``b`` and ``return`` will
embellish it, making it ``Writer b``. Putting it all together, we end up
with a function that takes ``Writer a`` and returns ``Writer b``,
exactly what ``fmap`` is supposed to produce.

Notice that this argument is very general: you can replace ``Writer``
with any type constructor. As long as it supports a fish operator and
``return``, you can define ``fmap`` as well. So the embellishment in the
Kleisli category is always a functor. (Not every functor, though, gives
rise to a Kleisli category.)

You might wonder if the ``fmap`` we have just defined is the same
``fmap`` the compiler would have derived for us with
``deriving Functor``. Interestingly enough, it is. This is due to the
way Haskell implements polymorphic functions. It’s called *parametric
polymorphism*, and it’s a source of so called *theorems for free*. One
of those theorems says that, if there is an implementation of ``fmap``
for a given type constructor, one that preserves identity, then it must
be unique.

.. rubric:: Covariant and Contravariant Functors
   :name: covariant-and-contravariant-functors

Now that we’ve reviewed the writer functor, let’s go back to the reader
functor. It was based on the partially applied function-arrow type
constructor:

::

    (->) r

We can rewrite it as a type synonym:

::

    type Reader r a = r -> a

for which the ``Functor`` instance, as we’ve seen before, reads:

::

    instance Functor (Reader r) where
        fmap f g = f . g

But just like the pair type constructor, or the ``Either`` type
constructor, the function type constructor takes two type arguments. The
pair and ``Either`` were functorial in both arguments — they were
bifunctors. Is the function constructor a bifunctor too?

Let’s try to make it functorial in the first argument. We’ll start with
a type synonym — it’s just like the ``Reader`` but with the arguments
flipped:

::

    type Op r a = a -> r

This time we fix the return type, ``r``, and vary the argument type,
``a``. Let’s see if we can somehow match the types in order to implement
``fmap``, which would have the following type signature:

::

    fmap :: (a -> b) -> (a -> r) -> (b -> r)

With just two functions taking ``a`` and returning, respectively, ``b``
and ``r``, there is simply no way to build a function taking ``b`` and
returning ``r``! It would be different if we could somehow invert the
first function, so that it took ``b`` and returned ``a`` instead. We
can’t invert an arbitrary function, but we can go to the opposite
category.

A short recap: For every category *C* there is a dual category
*C\ :sup:`op`*. It’s a category with the same objects as *C*, but with
all the arrows reversed.

| Consider a functor that goes between *C\ :sup:`op`* and some other
  category *D*:
| *F :: C\ :sup:`op` → D*
| Such a functor maps a morphism *f\ :sup:`op` :: a → b* in
  *C\ :sup:`op`* to the morphism *F f\ :sup:`op` :: F a → F b* in *D*.
  But the morphism *f\ :sup:`op`* secretly corresponds to some morphism
  *f :: b → a* in the original category *C*. Notice the inversion.

Now, *F* is a regular functor, but there is another mapping we can
define based on *F*, which is not a functor — let’s call it *G*. It’s a
mapping from *C* to *D*. It maps objects the same way *F* does, but when
it comes to mapping morphisms, it reverses them. It takes a morphism *f
:: b → a* in *C*, maps it first to the opposite morphism *f\ :sup:`op`
:: a → b* and then uses the functor F on it, to get *F f\ :sup:`op` :: F
a → F b*.

|Contravariant|

| Considering that *F a* is the same as *G a* and *F b* is the same as
  *G b*, the whole trip can be described as:
| *G f :: (b → a) → (G a → G b)*
| It’s a “functor with a twist.” A mapping of categories that inverts
  the direction of morphisms in this manner is called a *contravariant
  functor*. Notice that a contravariant functor is just a regular
  functor from the opposite category. The regular functors, by the way —
  the kind we’ve been studying thus far — are called *covariant*
  functors.

Here’s the typeclass defining a contravariant functor (really, a
contravariant *endo*\ functor) in Haskell:

::

    class Contravariant f where
        contramap :: (b -> a) -> (f a -> f b)

Our type constructor ``Op`` is an instance of it:

::

    instance Contravariant (Op r) where
        -- (b -> a) -> Op r a -> Op r b
        contramap f g = g . f

Notice that the function ``f`` inserts itself *before* (that is, to the
right of) the contents of ``Op`` — the function ``g``.

The definition of ``contramap`` for ``Op`` may be made even terser, if
you notice that it’s just the function composition operator with the
arguments flipped. There is a special function for flipping arguments,
called ``flip``:

::

    flip :: (a -> b -> c) -> (b -> a -> c)
    flip f y x = f x y

With it, we get:

::

    contramap = flip (.)

.. rubric:: Profunctors
   :name: profunctors

| We’ve seen that the function-arrow operator is contravariant in its
  first argument and covariant in the second. Is there a name for such a
  beast? It turns out that, if the target category is **Set**, such a
  beast is called a *profunctor*. Because a contravariant functor is
  equivalent to a covariant functor from the opposite category, a
  profunctor is defined as:
| *C\ :sup:`op` × D → Set*

Since, to first approximation, Haskell types are sets, we apply the name
``Profunctor`` to a type constructor ``p`` of two arguments, which is
contra-functorial in the first argument and functorial in the second.
Here’s the appropriate typeclass taken from the ``Data.Profunctor``
library:

::

    class Profunctor p where
      dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
      dimap f g = lmap f . rmap g
      lmap :: (a -> b) -> p b c -> p a c
      lmap f = dimap f id
      rmap :: (b -> c) -> p a b -> p a c
      rmap = dimap id

All three functions come with default implementations. Just like with
``Bifunctor``, when declaring an instance of ``Profunctor``, you have a
choice of either implementing ``dimap`` and accepting the defaults for
``lmap`` and ``rmap``, or implementing both ``lmap`` and ``rmap`` and
accepting the default for ``dimap``.

.. raw:: html

   <div id="attachment_4078" class="wp-caption aligncenter"
   data-shortcode="caption" style="width: 310px">

|dimap|
dimap

.. raw:: html

   </div>

Now we can assert that the function-arrow operator is an instance of a
``Profunctor``:

::

    instance Profunctor (->) where
      dimap ab cd bc = cd . bc . ab
      lmap = flip (.)
      rmap = (.)

Profunctors have their application in the Haskell lens library. We’ll
see them again when we talk about ends and coends.

.. rubric:: Challenges
   :name: challenges

#. Show that the data type:

   ::

       data Pair a b = Pair a b

   is a bifunctor. For additional credit implement all three methods of
   ``Bifunctor`` and use equational reasoning to show that these
   definitions are compatible with the default implementations whenever
   they can be applied.

#. Show the isomorphism between the standard definition of ``Maybe`` and
   this desugaring:

   ::

       type Maybe' a = Either (Const () a) (Identity a)

   Hint: Define two mappings between the two implementations. For
   additional credit, show that they are the inverse of each other using
   equational reasoning.

#. Let’s try another data structure. I call it a ``PreList`` because
   it’s a precursor to a ``List``. It replaces recursion with a type
   parameter ``b``.

   ::

       data PreList a b = Nil | Cons a b

   You could recover our earlier definition of a ``List`` by recursively
   applying ``PreList`` to itself (we’ll see how it’s done when we talk
   about fixed points).

   Show that ``PreList`` is an instance of ``Bifunctor``.

#. Show that the following data types define bifunctors in ``a`` and
   ``b``:

   ::

       data K2 c a b = K2 c

   ::

       data Fst a b = Fst a

   ::

       data Snd a b = Snd b

   For additional credit, check your solutions agains Conor McBride’s
   paper `Clowns to the Left of me, Jokers to the
   Right <http://strictlypositive.org/CJ.pdf>`__.

#. Define a bifunctor in a language other than Haskell. Implement
   ``bimap`` for a generic pair in that language.
#. Should ``std::map`` be considered a bifunctor or a profunctor in the
   two template arguments ``Key`` and ``T``? How would you redesign this
   data type to make it so?

Next: `Function
Types <https://bartoszmilewski.com/2015/03/13/function-types/>`__.

.. rubric:: Acknowledgment
   :name: acknowledgment

| As usual, big thanks go to Gershom Bazerman for reviewing this
  article.
| `Follow @BartoszMilewski <https://twitter.com/BartoszMilewski>`__

.. raw:: html

   <div class="wpcnt">

.. raw:: html

   <div class="wpa wpmrec wpmrec2x">

Advertisements

.. raw:: html

   <div class="u">

.. raw:: html

   </div>

.. raw:: html

   <div id="crt-1204545926" style="width:300px;height:250px;">

.. raw:: html

   </div>

.. raw:: html

   <div id="crt-1727841240" style="width:300px;height:250px;">

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="jp-post-flair"
   class="sharedaddy sd-rating-enabled sd-like-enabled sd-sharing-enabled">

.. raw:: html

   <div class="sharedaddy sd-sharing-enabled">

.. raw:: html

   <div
   class="robots-nocontent sd-block sd-social sd-social-icon-text sd-sharing">

.. rubric:: Share this:
   :name: share-this
   :class: sd-title

.. raw:: html

   <div class="sd-content">

-  `Reddit <https://bartoszmilewski.com/2015/02/03/functoriality/?share=reddit>`__
-  `More <#>`__
-  

.. raw:: html

   <div class="sharing-hidden">

.. raw:: html

   <div class="inner" style="display: none;">

-  `Twitter <https://bartoszmilewski.com/2015/02/03/functoriality/?share=twitter>`__
-  `LinkedIn <https://bartoszmilewski.com/2015/02/03/functoriality/?share=linkedin>`__
-  
-  `Google <https://bartoszmilewski.com/2015/02/03/functoriality/?share=google-plus-1>`__
-  `Pocket <https://bartoszmilewski.com/2015/02/03/functoriality/?share=pocket>`__
-  
-  `Facebook <https://bartoszmilewski.com/2015/02/03/functoriality/?share=facebook>`__
-  `Email <https://bartoszmilewski.com/2015/02/03/functoriality/?share=email>`__
-  
-  

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="like-post-wrapper-3549518-4008-59ae3bd2be1ae"
   class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded"
   data-src="//widgets.wp.com/likes/#blog_id=3549518&amp;post_id=4008&amp;origin=bartoszmilewski.wordpress.com&amp;obj_id=3549518-4008-59ae3bd2be1ae"
   data-name="like-post-frame-3549518-4008-59ae3bd2be1ae">

.. rubric:: Like this:
   :name: like-this
   :class: sd-title

.. raw:: html

   <div class="likes-widget-placeholder post-likes-widget-placeholder"
   style="height: 55px;">

Like Loading...

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="jp-relatedposts" class="jp-relatedposts">

.. rubric:: *Related*
   :name: related
   :class: jp-relatedposts-headline

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div class="post-info">

.. raw:: html

   </div>

.. raw:: html

   <div class="post-footer">

 

.. raw:: html

   </div>

.. raw:: html

   </div>

.. rubric:: 18 Responses to “Functoriality”
   :name: comments

#. 

   .. raw:: html

      <div id="comment-42375">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-42375">

   .. raw:: html

      <div class="comment-author vcard">

   |image6| Jarek Przygódzki Says:

   .. raw:: html

      </div>

   `February 23, 2015 at 8:04
   am <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-42375>`__
   Reblogged this on `Jarek Przygódzki. Blog
   programisty <https://jarekprzygodzki.wordpress.com/2015/02/23/functoriality/>`__.

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-43110">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-43110">

   .. raw:: html

      <div class="comment-author vcard">

   |image7| Andrew Says:

   .. raw:: html

      </div>

   `March 11, 2015 at 9:36
   am <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-43110>`__
   We are patiently waiting for next chunk of wisdom. I think it will be
   natural transformations and monads from CT point of view.

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-43186">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-43186">

   .. raw:: html

      <div class="comment-author vcard">

   `Function Types \|   Bartosz Milewski's Programming
   Cafe <https://bartoszmilewski.com/2015/03/13/function-types/>`__
   Says:

   .. raw:: html

      </div>

   `March 13, 2015 at 1:08
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-43186>`__
   […] given the mapping h from z' to z, is a mapping from z'×a to z×a.
   And now, after discussing the functoriality of the product, we know
   how to do it. Because the product itself is a functor (more precisely
   an endo-bi-functor), […]

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-43962">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-43962">

   .. raw:: html

      <div class="comment-author vcard">

   |image8| `Zheka Kozlov <http://www.facebook.com/100000209203366>`__
   Says:

   .. raw:: html

      </div>

   `March 29, 2015 at 7:04
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-43962>`__
   Can be List rewritten in terms of Either like Maybe?

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-43964">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-43964">

   .. raw:: html

      <div class="comment-author vcard">

   |image9| `Bartosz Milewski <http://BartoszMilewski.com>`__ Says:

   .. raw:: html

      </div>

   `March 29, 2015 at 9:29
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-43964>`__
   List is a recursive data structure, so it’s a little more involved
   than that. The usual way of defining recursive data structures is to
   define a functor, in this case:

   ::

       ListF e a = Nil | Cons e a

   which is not recursive but it has a free type parameter ``a``
   inserted in place of recursion (here, in place of the tail). This
   part can be rewritten in terms of ``Either``, etc. A recursive list
   is then defined as a fixed point of this functor. See my posts about
   algebras.

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-44416">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-44416">

   .. raw:: html

      <div class="comment-author vcard">

   |image10| `NN <http://www.nemerleweb.com>`__ Says:

   .. raw:: html

      </div>

   `April 7, 2015 at 10:33
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-44416>`__
   Can I say that a TriFunctor where (a -> x) -> (b -> y) -> (c -> z) ->
   f a b c -> f x y z , is isomorphic to combination of Bifunctor with
   Functor ?

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-44466">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-44466">

   .. raw:: html

      <div class="comment-author vcard">

   |image11| `Bartosz Milewski <http://BartoszMilewski.com>`__ Says:

   .. raw:: html

      </div>

   `April 8, 2015 at 5:35
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-44466>`__
   What do you mean by “combination”?

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-44475">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-44475">

   .. raw:: html

      <div class="comment-author vcard">

   |image12| `NN <http://www.nemerleweb.com>`__ Says:

   .. raw:: html

      </div>

   `April 8, 2015 at 9:18
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-44475>`__
   Is it correct to say that such TriFunctor is isomorphic to Functor
   which receives a tuple of 3 values or a Bifunctor which receives a
   tuple with 2 values as first argument and a single value as a second
   argument ?

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-44498">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-44498">

   .. raw:: html

      <div class="comment-author vcard">

   |image13| `Bartosz Milewski <http://BartoszMilewski.com>`__ Says:

   .. raw:: html

      </div>

   `April 9, 2015 at 10:27
   am <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-44498>`__
   I don’t have a formal proof but the intuition is that functors are
   morphisms in the category of (small) categories **Cat** (see my blog
   post on natural transformation for more details), which is cartesian
   closed. It means that it supports products and currying. So a
   trifunctor is just a functor that returns a bifunctor.

   This is definitely true in Haskell, where type constructors are
   curried, and ``trimap`` may be implemented in terms of map and bimap.

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-47237">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-47237">

   .. raw:: html

      <div class="comment-author vcard">

   |image14| `karkunow <http://karkunow.wordpress.com>`__ Says:

   .. raw:: html

      </div>

   `June 5, 2015 at 1:34
   am <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-47237>`__
   I’ve noticed small error in the declaration section of the
   Contravariant instance of the Op type. So I guess it would be better
   to:

   | 1). Rename Op b to Op r in the first line.
   | 2). Set correct concrete types in the comment.
   | 3). (optional) Add one more comment with type, where Ops are
     replaced with the ‘real’ function types (Op r a = a -> r).

   Then this section will look like:

   | instance Contravariant (Op r) where
   | — (b -> a) -> Op r a -> Op r b =
   | — = (b -> a) -> (a->r) -> (b->r)
   | contramap f g = g . f

   Now it looks more clearly to me, don’t it?

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-47267">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-47267">

   .. raw:: html

      <div class="comment-author vcard">

   |image15| `Bartosz Milewski <http://BartoszMilewski.com>`__ Says:

   .. raw:: html

      </div>

   `June 5, 2015 at 6:21
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-47267>`__
   @karkunov: Good catch! Fixed it!

   The full Haskell example would use ``newtype`` and pattern matching,
   but I didn’t want to obscure the simple point.

   ::

       newtype Op r a = Op (a -> r)

       instance Contravariant (Op r) where
           -- (b -> a) -> Op r a -> Op r b
           contramap f (Op g) = Op (g . f)

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-50123">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-50123">

   .. raw:: html

      <div class="comment-author vcard">

   |image16| `greg nwosu
   (@buddistfist) <http://twitter.com/buddistfist>`__ Says:

   .. raw:: html

      </div>

   `July 15, 2015 at 12:11
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-50123>`__
   | you wrote : “If you’re getting a little lost, try applying BiComp
     to Either, Const (), Identity, a, and b, in this order.” I found
     const () to be the wrong type and had to bind instead to (
     ``const`` ()). Thus:
   | let x = BiComp (either (``const`` ()) id)

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-50124">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-50124">

   .. raw:: html

      <div class="comment-author vcard">

   |image17| `greg nwosu
   (@buddistfist) <http://twitter.com/buddistfist>`__ Says:

   .. raw:: html

      </div>

   `July 15, 2015 at 12:12
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-50124>`__
   imagine I have backticks around my const expression

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-50126">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-50126">

   .. raw:: html

      <div class="comment-author vcard">

   |image18| `Bartosz Milewski <http://BartoszMilewski.com>`__ Says:

   .. raw:: html

      </div>

   `July 15, 2015 at 1:16
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-50126>`__
   What I meant is this:

   ::

       type Perhaps a b = BiComp Either (Const ()) Identity a b

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-53562">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-53562">

   .. raw:: html

      <div class="comment-author vcard">

   |image19| Daniel Asher Says:

   .. raw:: html

      </div>

   `September 16, 2015 at 1:50
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-53562>`__
   thank you, Bartosz, for this masterpiece of clarity.

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-67978">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-67978">

   .. raw:: html

      <div class="comment-author vcard">

   |image20| `Gyula Csom <http://gravatar.com/csomgyula>`__ Says:

   .. raw:: html

      </div>

   `December 10, 2016 at 5:06
   am <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-67978>`__
   It looks like that there’s a slight mistake in the definition of
   ``Bifunctor``. The definition of the ``second`` function seems to be
   a typo. If I understand well, then: instead of ``second = bimap id``
   it should be ``second = bimap id h``.

   The problem seems to appear in the original Haskell source as well
   (ie. Control.Bifunctor v.0.44.4).

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-67981">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-67981">

   .. raw:: html

      <div class="comment-author vcard">

   |image21| `Bartosz Milewski <http://BartoszMilewski.com>`__ Says:

   .. raw:: html

      </div>

   `December 10, 2016 at 10:04
   am <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-67981>`__
   @Gyula Csom: Notice that the original Haskell source compiles, so the
   compiler understands it. You can look at ``bimap`` as a function of
   three arguments, or a function of two arguments returning a function
   of one argument, or a function of one argument returning a function
   of two arguments:

   ::

       bimap :: (a -> c) -> ( (b -> d) -> f a b -> f c d )

   It’s the latter interpretation that makes this code work. It’s just
   currying.

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

#. 

   .. raw:: html

      <div id="comment-67986">

   .. raw:: html

      </div>

   .. raw:: html

      <div id="div-comment-67986">

   .. raw:: html

      <div class="comment-author vcard">

   |image22| Csom Gyula Says:

   .. raw:: html

      </div>

   `December 10, 2016 at 3:07
   pm <https://bartoszmilewski.com/2015/02/03/functoriality/#comment-67986>`__
   Thanks for your reply!

   I’ve got it:-) Also I’ve caught my mistake. There’s no argument in
   the declaration of ``second``. That is: this would be mistaken:
   ``second h = bimap id``. But the declaration is different:
   ``second = bimap id`` and this works through currying as you pointed.

   .. raw:: html

      <div class="reply">

   .. raw:: html

      </div>

   .. raw:: html

      </div>

.. raw:: html

   <div class="navigation">

.. raw:: html

   <div class="alignleft">

.. raw:: html

   </div>

.. raw:: html

   <div class="alignright">

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="respond" class="comment-respond">

.. rubric:: Leave a Reply `Cancel
   reply </2015/02/03/functoriality/#respond>`__
   :name: reply-title
   :class: comment-reply-title

.. raw:: html

   <div class="comment-form-field comment-textarea">

Enter your comment here...

.. raw:: html

   <div id="comment-form-comment">

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="comment-form-identity">

.. raw:: html

   <div id="comment-form-nascar">

Fill in your details below or click an icon to log in:

-  ` <#comment-form-guest>`__
-  ` <#comment-form-load-service:WordPress.com>`__
-  ` <#comment-form-load-service:Twitter>`__
-  ` <#comment-form-load-service:Facebook>`__
-  

.. raw:: html

   </div>

.. raw:: html

   <div id="comment-form-guest" class="comment-form-service selected">

.. raw:: html

   <div class="comment-form-padder">

.. raw:: html

   <div class="comment-form-avatar">

|Gravatar|

.. raw:: html

   </div>

.. raw:: html

   <div class="comment-form-fields">

.. raw:: html

   <div class="comment-form-field comment-form-email">

Email (required) (Address never made public)

.. raw:: html

   <div class="comment-form-input">

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div class="comment-form-field comment-form-author">

Name (required)

.. raw:: html

   <div class="comment-form-input">

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div class="comment-form-field comment-form-url">

Website

.. raw:: html

   <div class="comment-form-input">

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="comment-form-wordpress" class="comment-form-service">

.. raw:: html

   <div class="comment-form-padder">

.. raw:: html

   <div class="comment-form-avatar">

|WordPress.com Logo|

.. raw:: html

   </div>

.. raw:: html

   <div class="comment-form-fields">

**** You are commenting using your WordPress.com account.
( `Log Out <javascript:HighlanderComments.doExternalLogout(%20'wordpress'%20);>`__ / `Change <#>`__ )

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="comment-form-twitter" class="comment-form-service">

.. raw:: html

   <div class="comment-form-padder">

.. raw:: html

   <div class="comment-form-avatar">

|Twitter picture|

.. raw:: html

   </div>

.. raw:: html

   <div class="comment-form-fields">

**** You are commenting using your Twitter account.
( `Log Out <javascript:HighlanderComments.doExternalLogout(%20'twitter'%20);>`__ / `Change <#>`__ )

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="comment-form-facebook" class="comment-form-service">

.. raw:: html

   <div class="comment-form-padder">

.. raw:: html

   <div class="comment-form-avatar">

|Facebook photo|

.. raw:: html

   </div>

.. raw:: html

   <div class="comment-form-fields">

**** You are commenting using your Facebook account.
( `Log Out <javascript:HighlanderComments.doExternalLogout(%20'facebook'%20);>`__ / `Change <#>`__ )

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="comment-form-googleplus" class="comment-form-service">

.. raw:: html

   <div class="comment-form-padder">

.. raw:: html

   <div class="comment-form-avatar">

|Google+ photo|

.. raw:: html

   </div>

.. raw:: html

   <div class="comment-form-fields">

**** You are commenting using your Google+ account.
( `Log Out <javascript:HighlanderComments.doExternalLogout(%20'googleplus'%20);>`__ / `Change <#>`__ )

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="comment-form-load-service" class="comment-form-service">

.. raw:: html

   <div class="comment-form-posting-as-cancel">

`Cancel <javascript:HighlanderComments.cancelExternalWindow();>`__

.. raw:: html

   </div>

Connecting to %s

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="comment-form-subscribe">

Notify me of new comments via email.

Notify me of new posts via email.

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div style="clear: both">

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="sidebar">

.. rubric:: Archived Entry
   :name: archived-entry

-  **Post Date :**
-  February 3, 2015 at 5:39 pm
-  **Category :**
-  `C++ <https://bartoszmilewski.com/category/c/>`__, `Category
   Theory <https://bartoszmilewski.com/category/category-theory/>`__,
   `Functional
   Programming <https://bartoszmilewski.com/category/functional-programming/>`__,
   `Haskell <https://bartoszmilewski.com/category/haskell/>`__,
   `Programming <https://bartoszmilewski.com/category/programming/>`__
-  **Do More :**
-  You can `leave a response <#respond>`__, or
   `trackback <https://bartoszmilewski.com/2015/02/03/functoriality/trackback/>`__
   from your own site.

.. raw:: html

   </div>

`Blog at WordPress.com. <https://wordpress.com/?ref=footer_blog>`__

.. raw:: html

   <div style="display:none">

.. raw:: html

   <div class="grofile-hash-map-e9473adb752e81e6cd6279cf999df7a4">

.. raw:: html

   </div>

.. raw:: html

   <div class="grofile-hash-map-a37d86b7d709785662decc035368ad8e">

.. raw:: html

   </div>

.. raw:: html

   <div class="grofile-hash-map-c6e2d6eea25a87961ac3a6dfbfbe7805">

.. raw:: html

   </div>

.. raw:: html

   <div class="grofile-hash-map-c018f213204496b4bbf481e7c8e6c15c">

.. raw:: html

   </div>

.. raw:: html

   <div class="grofile-hash-map-52d445b3234e100bc93c9accfce29d98">

.. raw:: html

   </div>

.. raw:: html

   <div class="grofile-hash-map-6996fe77db9f65db1834b998b5222f9b">

.. raw:: html

   </div>

.. raw:: html

   <div class="grofile-hash-map-7347a01d99764b7f8f6f4baa5f385be4">

.. raw:: html

   </div>

.. raw:: html

   <div class="grofile-hash-map-3e713a56c1bee057a6c7a608afa4be42">

.. raw:: html

   </div>

.. raw:: html

   <div class="grofile-hash-map-f19df03863d5f739a01dbb0bc9ba90b3">

.. raw:: html

   </div>

.. raw:: html

   <div class="grofile-hash-map-f19df03863d5f739a01dbb0bc9ba90b3">

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="carousel-reblog-box">

Post to

.. raw:: html

   <div class="submit">

`Cancel <#>`__

.. raw:: html

   </div>

.. raw:: html

   <div class="arrow">

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="sharing_email" style="display: none;">

Send to Email Address Your Name Your Email Address

.. raw:: html

   <div id="sharing_recaptcha" class="recaptcha">

.. raw:: html

   </div>

|loading| `Cancel <#cancel>`__

.. raw:: html

   <div class="errors errors-1" style="display: none;">

Post was not sent - check your email addresses!

.. raw:: html

   </div>

.. raw:: html

   <div class="errors errors-2" style="display: none;">

Email check failed, please try again

.. raw:: html

   </div>

.. raw:: html

   <div class="errors errors-3" style="display: none;">

Sorry, your blog cannot share posts by email.

.. raw:: html

   </div>

.. raw:: html

   </div>

.. raw:: html

   <div id="likes-other-gravatars">

.. raw:: html

   <div class="likes-text">

%d bloggers like this:

.. raw:: html

   </div>

.. raw:: html

   </div>

|image29|

.. raw:: html

   </div>

.. raw:: html

   </div>

.. |Bifunctor| image:: https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg?w=300&h=286
   :class: aligncenter size-medium wp-image-4068
   :width: 300px
   :height: 286px
   :target: https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg
.. |Bimap| image:: https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg?w=300&h=292
   :class: wp-image-4070 size-medium
   :width: 300px
   :height: 292px
   :target: https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg
.. |First| image:: https://bartoszmilewski.files.wordpress.com/2015/01/first.jpg?w=150&h=124
   :class: wp-image-4071 size-thumbnail
   :width: 150px
   :height: 124px
   :target: https://bartoszmilewski.files.wordpress.com/2015/01/first.jpg
.. |Second| image:: https://bartoszmilewski.files.wordpress.com/2015/01/second.jpg?w=150&h=138
   :class: wp-image-4072 size-thumbnail
   :width: 150px
   :height: 138px
   :target: https://bartoszmilewski.files.wordpress.com/2015/01/second.jpg
.. |Contravariant| image:: https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg?w=300&h=295
   :class: aligncenter size-medium wp-image-4077
   :width: 300px
   :height: 295px
   :target: https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg
.. |dimap| image:: https://bartoszmilewski.files.wordpress.com/2015/01/dimap.jpg?w=300&h=243
   :class: size-medium wp-image-4078
   :width: 300px
   :height: 243px
   :target: https://bartoszmilewski.files.wordpress.com/2015/01/dimap.jpg
.. |image6| image:: https://2.gravatar.com/avatar/e9473adb752e81e6cd6279cf999df7a4?s=48&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image7| image:: https://1.gravatar.com/avatar/a37d86b7d709785662decc035368ad8e?s=48&d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image8| image:: https://i0.wp.com/graph.facebook.com/v2.2/100000209203366/picture?q=type%3Dlarge%26_md5%3Dc97e8650acfe44d837ddbb18a75d7399&resize=48%2C48
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image9| image:: https://0.gravatar.com/avatar/c018f213204496b4bbf481e7c8e6c15c?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image10| image:: https://2.gravatar.com/avatar/52d445b3234e100bc93c9accfce29d98?s=48&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image11| image:: https://0.gravatar.com/avatar/c018f213204496b4bbf481e7c8e6c15c?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image12| image:: https://2.gravatar.com/avatar/52d445b3234e100bc93c9accfce29d98?s=48&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image13| image:: https://0.gravatar.com/avatar/c018f213204496b4bbf481e7c8e6c15c?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image14| image:: https://0.gravatar.com/avatar/6996fe77db9f65db1834b998b5222f9b?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image15| image:: https://0.gravatar.com/avatar/c018f213204496b4bbf481e7c8e6c15c?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image16| image:: https://i2.wp.com/pbs.twimg.com/profile_images/378800000118625501/51860326faa5b01f8a6be8320b4aa27c_normal.jpeg?resize=48%2C48
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image17| image:: https://i2.wp.com/pbs.twimg.com/profile_images/378800000118625501/51860326faa5b01f8a6be8320b4aa27c_normal.jpeg?resize=48%2C48
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image18| image:: https://0.gravatar.com/avatar/c018f213204496b4bbf481e7c8e6c15c?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image19| image:: https://0.gravatar.com/avatar/3e713a56c1bee057a6c7a608afa4be42?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image20| image:: https://0.gravatar.com/avatar/f19df03863d5f739a01dbb0bc9ba90b3?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image21| image:: https://0.gravatar.com/avatar/c018f213204496b4bbf481e7c8e6c15c?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |image22| image:: https://0.gravatar.com/avatar/f19df03863d5f739a01dbb0bc9ba90b3?s=48&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D48&r=G
   :class: avatar avatar-48
   :width: 48px
   :height: 48px
.. |Gravatar| image:: https://1.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=25
   :class: no-grav
   :width: 25px
   :target: https://gravatar.com/site/signup/
.. |WordPress.com Logo| image:: https://1.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=25
   :class: no-grav
   :width: 25px
.. |Twitter picture| image:: https://1.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=25
   :class: no-grav
   :width: 25px
.. |Facebook photo| image:: https://1.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=25
   :class: no-grav
   :width: 25px
.. |Google+ photo| image:: https://1.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=25
   :class: no-grav
   :width: 25px
.. |loading| image:: https://s2.wp.com/wp-content/mu-plugins/post-flair/sharing/images/loading.gif
   :class: loading
   :width: 16px
   :height: 16px
.. |image29| image:: https://pixel.wp.com/b.gif?v=noscript

